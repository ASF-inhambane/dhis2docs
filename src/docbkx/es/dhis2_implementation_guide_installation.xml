<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" []>
<chapter>
  <title>Instalación</title>
  <para>El capítulo de instalación proporciona información sobre cómo instalar DHIS 2 en diversos contextos, incluidos un servidor central online, una red local offline, una aplicación independiente y un paquete autocontenido denominado DHIS 2 Live.</para>
  <para>DHIS 2 funciona en toda plataforma para la cual exista una versión 6 o superior del Entorno de Ejecución de Java (Java Runtime Environment), lo que incluye los sistemas operativos más populares como son Windows, Linux y Mac. DHIS 2 funciona con sistemas de bases de datos relacionales como PostgreSQL, MySQL, H2 y Derby. DHIS 2 está empaquetado como un fichero estándar Java Web Archive (fichero WAR) y por tanto se ejecuta en cualquier contenedor Servlet como Tomcat o Jetty.</para>
  <para>El equipo DHIS 2 recomienda el sistema operativo Ubuntu 12.04 LTS, el sistema de base de datos PostgreSQL y el contenedor Servlet Tomcat como el entorno preferido para las instalaciones en servidor. Los sistemas mencionados pueden considerarse líderes de mercado en sus respectivos dominios y han sido probados intensivamente durante muchos años.</para>
  <para>Este capítulo ofrece una guía para montar la citada pila de tecnologías (Ubuntu-PostgreSQL-Tomcat). Sin embargo, esta guía debe leerse como un itinerario para montar y poner en marcha DHIS 2, y no como una documentación exhaustiva sobre el entorno mencionado. Para una lectura en profundidad, recomendamos seguir la documentación oficial de Ubuntu, PostgreSQL y Tomcat.</para>
  <section>
    <title>Montaje del servidor</title>
    <para>Esta sección describe cómo montar una instancia de servidor de DHIS 2 en Ubuntu 12.04 64 bit con PostgreSQL como sistema de base de datos y con Tomcat como contenedor Servlet. El término <emphasis role="italic">invocar</emphasis> indica la ejecución de un determinado comando en el terminal.</para>
    <para>Para un servidor nacional los requisitos hardware son un procesador quad-core 2GHz o superior y 12GB de RAM o superior. Nótese que se requiere un sistema operativo de 64 bits para utilizar más de 4 GB de RAM, por lo que se recomienda la edición Ubuntu 12.04 de 64 bits.</para>
    <para>En esta guía asumiremos que 4 GB se asignan a PostgreSQL y 7GB de RAM se asignan a Tomcat. <emphasis role="italic">¡Si estás utilizando una configuración distinta por favor ajusta los valores sugeridos en consecuencia!</emphasis>. Los pasos que marcaremos como <emphasis role="italic">opcional</emphasis>, como el paso de ajuste de rendimiento, pueden realizarse en un momento posterior.</para>
    <para><emphasis role="bold">Crear nuevo usuario (opcional)</emphasis></para>
    <para>Tal vez queramos crear un usuario dedicado para ejecutar DHIS - no es recomendable ejecutarlo como usuario root. Creamos un nuevo usuario llamado dhis invocando <code>useradd -d /home/dhis -m dhis -s /bin/bash</code>   A continuación habilitamos al usuario para realizar operaciones como root temporalmente invocando <code>adduser dhis admin</code>   Si no hay grupo admin en el sistema, crearemos dicho grupo primero invocando <code>groupadd admin</code>   Después invocamos <code>passwd dhis</code> para fijar la contraseña de esta nueva cuenta de usuario. Nos aseguraremos de poner una contraseña fuerte con al menos 15 caracteres aleatorios. Tal vez queramos deshabilitar el login remoto para la cuenta de root, logrando así mayor seguridad, invocando <emphasis role="italic"> sudo passwd -l root</emphasis>.</para>
    <para><emphasis role="bold">Ajuste del núcleo del sistema operativo</emphasis></para>
    <para>Estas configuraciones son opcionales excepto para la configuración de la memoria compartida, que es un requisito para la asignación de memoria para PostgreSQL. Abrimos el fichero de configuración del núcleo o kernel invocando <code>sudo nano /etc/sysctl.conf</code>   Al final del fichero añadiremos las líneas siguientes y guardaremos el fichero.</para>
    <screen>kernel.shmmax = 1073741824
net.core.rmem_max = 8388608
net.core.wmem_max = 8388608</screen>
    <para>Hacemos que los cambios tengan efecto invocando <code>sudo sysctl -p</code></para>
    <para><emphasis role="bold">Instalar Java</emphasis></para>
    <para>Instalamos Java invocando lo siguiente:</para>
    <screen>sudo apt-get install openjdk-7-jdk

sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-openjdk/bin/java 1

sudo update-alternatives --set java /usr/lib/jvm/java-7-openjdk/bin/java</screen>
    <para>A continuación es importante chequear que la ruta de los binarios de Java es correcta, ya que puede cambiar de un sistema a otro, por ejemplo en sistemas AMD podríamos encontrar algo como <emphasis role="italic">../java-7-openjdk-amd64/..</emphasis>. Chequeamos a continuación que nuestra instalación está bien invocando <code>java -version</code></para>
    <para><emphasis role="bold">Instalar PostgreSQL</emphasis></para>
    <para>Instalamos PostgreSQL invocando <code>sudo apt-get install postgresql-9.1</code></para>
    <para>Cambiamos al usuario de postgres invocando <code>sudo su postgres</code>  </para>
    <para>Creaamos ahora un usuario sin privilegios llamado <emphasis role="italic">dhis</emphasis> invocando
        <code>createuser -SDRP dhis</code>   Introducimos una contraseña segura cuando aparece el prompt. Creamos una base de datos invocando <code>createdb -O dhis dhis2</code>   Regresamos a nuestra sesión de usuario invocando <code>exit</code>   </para>
        <para>Ahora ya tenemos un usuario PostgreSQL llamado <emphasis role="italic">dhis</emphasis> y una base de datos llamada <emphasis role="italic">dhis2</emphasis>.</para>
    <para>Continuamos ajustando el rendimiento abriendo el fichero siguiente invocando</para>
    <para><code>sudo nano /etc/postgresql/9.1/main/postgresql.conf</code></para>
    <para>y fijando las propiedades siguientes:</para>
    <para><code>shared_buffers = 512MB</code></para>
    <para>Esto determina cuánta memoria PostgreSQL puede utilizarse para almacenar datos de consultas. Se ajusta muy pequeña por defecto porque depende de la memoria compartida del núcleo, que es reducida en algunos sistemas operativos. </para>
    <para><code>effective_cache_size = 3500MB</code></para>
    <para>Es una estimación de cuánta memoria está disponible para almacenar (no para asignar) y es usada por PostgreSQL para determinar si un plan de consultas se adecuará a la memoria o no (aquí una configuración demasiado grande podría resultar en un comportamiento impredecible y lento).</para>
    <para><code>checkpoint_segments = 32</code></para>
    <para>PostgreSQL graba las nuevas transacciones en un fichero de log llamado WAL en segmentos de tamaño 16MB. Cuando se graba una cantidad de segmentos dada sucede un checkpoint. Configurar esta cifra en un valor mayor nos permite por tanto mejorar el rendimiento de sistemas de escritura pesada como DHIS 2.</para>
    <para><code>checkpoint_completion_target = 0.8</code></para>
    <para>Determina el porcentaje de segmentos completos antes de que aparezca un checkpoint. Fijar este número en un valor alto amplía por tanto la transcripción y reduce la sobrecarga de escritura promedio.</para>
    <para><code>wal_buffers = 4MB</code></para>
    <para>Fija la memoria utilizada para buffer durante el proceso de escritura WAL. Aumentar este valor puede mejorar el rendimiento en sistemas de escritura pesada.</para>
    <para><code>synchronous_commit = off</code></para>
    <para>Especifica si las asignaciones de transacción van a esperar a que se escriban los registros WAL en el disco antes de regresar al cliente o no. Fijar esto en off mejora el rendimiento considerablemente. También implica que habrá un pequeño retardo entre la transacción reportada con éxito al cliente y que esté realmente guardada, pero el estado de la base de datos no puede corromperse y es una buena alternativa en sistemas de producción intensiva y escritura pesada como DHIS 2.</para>
    <para><code>wal_writer_delay = 10000ms</code></para>
    <para>Especifica el retraso entre operaciones de escritura WAL. Fijar esto a un valor grande mejora el rendimiento en sistemas de escritura pesada ya que potencialmente pueden ejecutarse muchas operaciones de escritura en un único envío al disco.</para>
    <para>Reiniciar PostgreSQL invocando <code>sudo /etc/init.d/postgresql restart</code></para>
    <para><emphasis role="bold">Fijar la configuración de la base de datos</emphasis></para>
    <para>La información de conexión de la base de datos llega a DHIS 2 a través de un fichero de configuración llamado <emphasis role="italic">hibernate.properties</emphasis>. Creamos este fichero y lo guardamos en una ubicación adecuada. El fichero correspondiente al montaje anterior tiene las siguientes propiedades:</para>
    <para><screen>hibernate.dialect = org.hibernate.dialect.PostgreSQLDialect
hibernate.connection.driver_class = org.postgresql.Driver
hibernate.connection.url = jdbc:postgresql:dhis2
hibernate.connection.username = dhis
hibernate.connection.password = xxxx
hibernate.hbm2ddl.auto = update</screen></para>
    <para>Un error frecuente es dejar un espacio en blanco después del último valor de propiedad - asegúrate de que no hay espacios en blanco al final de ninguna línea en este fichero. También debemos recordar que este fichero contiene la contraseña en claro de nuestra base de datos dhis2 de modo que deberemos protegerlo de accesos no autorizados. Para hacer esto invocamos <code>chmod 0600 hibernate.properties</code> que garantiza que solo el usuario dhis que es propietario del fichero puede leer o escribir en él.</para>
    <para><emphasis role="bold">Instalar Tomcat</emphasis></para>
    <para>Descarga la distribución binaria de Tomcat de <emphasis role="italic">http://tomcat.apache.org/download-70.cgi</emphasis>. Una herramienta útil para descargar ficheros desde la web es <emphasis role="italic">wget</emphasis>. Extraemos el fichero en una ubiación adecuada. Esta guía asume que hemos navegado al directorio root del fichero extraido.</para>
    <para>Limpiamos las aplicaciones web preinstaladas invocando <code>rm -rf webapps/*</code> Descargamos el último fichero WAR de DHIS 2 desde <emphasis role="italic">http://dhis2.org/download</emphasis>, lo movemos al directorio <emphasis role="italic">webapps</emphasis> y lo renombramos como <emphasis role="italic">ROOT.war</emphasis></para>
    <para>Abrimos el fichero <emphasis role="italic">bin/setclasspath.sh</emphasis> y añadimos las líneas que siguen. Lo primero será fijar la ubicación de nuestro Java Runtime Environment, lo segundo será dedicar memoria a Tomcat y lo tercero será fijar la ubicación en la que DHIS 2 buscará el fichero de configuración <emphasis role="italic">hibernate.properties</emphasis>. Es importante aquí que chequeemos que la ruta a la ubicación del JDK es correcta. Notemos que deberemos ajustar esto a nuestro entorno:</para>
    <para><screen>export JAVA_HOME=&apos;/usr/lib/jvm/java-7-openjdk&apos;
export JAVA_OPTS=&apos;-Xmx6000m -Xms3000m -XX:MaxPermSize=800m -XX:PermSize=400m&apos;
export DHIS2_HOME=&apos;/home/dhis/config&apos;</screen></para>
    <para>Si necesitamos cambiar el <emphasis role="italic">puerto</emphasis> en el que Tomcat escucha las peticiones, podemos abrir el fichero de configuración de Tomcat <emphasis role="italic">/conf/server.xml</emphasis>, encontrar el elemento <emphasis role="italic">&lt;Connector&gt;</emphasis> que no está comentado y cambiar el valor de su atributo <emphasis role="italic">puerto</emphasis> por el número de puerto deseado.</para>
    <para>El log será nuestra primera fuente de información cuando queramos monitorear el comportamiento de Tomcat. Podemos ver fácilmente el log invocando <code>tail -f logs/catalina.out</code></para>
    <para><emphasis role="bold">Ejecutar DHIS 2</emphasis></para>
    <para>Para terminar haremos ejecutable el script de arranque invocando <code>chmod 755 bin/*</code>   Ahora podemos arrancar DHIs 2 invocando <code>bin/startup.sh</code>   Podemos monitorear el log invocando <code>tail -f logs/catalina.out</code>   Podemos detener DHIS 2 invocando <code>bin/shutdown.sh</code>   Finalemente, asumiendo que el fichero WAR se llama ahora ROOT.war, podemos acceder a nuestra instancia DHIS a través del navegador web en <emphasis role="italic">http://localhost:8080</emphasis>.</para>
  </section>







  <section>
    <title>Configuración reversa proxy</title>
    <para>A reverse proxy is a proxy server that acts on behalf of a server. Using a reverse proxy in combination with a servlet container is optional but has many advantages:</para>
    <itemizedlist>
      <listitem>
        <para>Requests can be mapped and passed on to multiple servlet containers - this improves flexibility and makes it easier to run multiple instances of DHIS on the same server. It also makes it possible to change the internal server setup without affecting clients.</para>
      </listitem>
      <listitem>
        <para>The DHIS application can be run as a non-root user on a port different than 80 which reduces the consequences of session hijacking.</para>
      </listitem>
      <listitem>
        <para>The reverse proxy can  act as a single SSL server and be configured to inspect requests for malicious content, log requests and responses and provide non-sensitive error messages which will improve security.</para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Instalación básica de nginx</title>
      <para>We recommend using nginx  (http://wiki.nginx.org) as reverse proxy due to its low memory footprint and ease of use. To get the latest version we recommend installing from source:</para>
      <screen>sudo apt-get install make gcc libpcre3 libpcre3-dev zlibc zlib1g zlib1g-dev libssl-dev openssl</screen>
      <para><screen>wget http://nginx.org/download/nginx-1.0.14.tar.gz
tar xzvf nginx-1.0.14.tar.gz
cd nginx-1.0.14
/configure --with-http_ssl_module
make
sudo make install
</screen></para>
      <para>nginx can now be started and stopped with the following commands:</para>
      <para><screen>sudo /usr/local/nginx/sbin/nginx
sudo /usr/local/nginx/sbin/nginx -s stop</screen></para>
      <para>Now that we have installed nginx we will now continue to configure regular proxying of requests to our Tomcat instance, which we assume runs at <emphasis role="italic">http://localhost:8080</emphasis>. To configure nginx you can open the configuration file by invoking</para>
      <para><code>sudo nano /usr/local/nginx/conf/nginx.conf</code></para>
      <para>nginx configuration is built around a hierarchy of blocks representing http, server and location, where each block inherit settings from parent blocks. The following snippet will configure nginx to proxy pass (redirect) requests from port 80 (which is the port nginx will listen on by default) to our Tomcat instance. It will also make nginx serve requests for static content such as javascript, stylesheets and images and instruct clients to cache it for 4 days which will reduce the load on Tomcat and improve overall performance. Include the following configuration in nginx.conf:</para>
      <para><screen><![CDATA[server {
  listen               80;
  client_max_body_size 10M; # Default 1M, change it!

  # Serve static content
  # Root points to your DHIS webapp location, update it!

  location ~ (\.js$|\.css$|\.gif$|\.woff$|\.ttf$|\.eot$|^/images/|^/icons/|^/dhis-web-commons/.*\.png$) {
    root     /home/dhis/tomcat/webapps/ROOT;
    expires  4d;
  } 

  # Proxy pass to servlet container

  location / {
    proxy_pass        http://localhost:8080/;
    proxy_redirect    off;
    proxy_set_header  Host            $host;
    proxy_set_header  X-Real-IP       $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
  }
}]]></screen></para>
      <para>You can now access your DHIS instance at <emphasis role="italic">http://localhost</emphasis>. Since  the reverse proxy has been set up we can improve security by making Tomcat only listen for local connections. In <emphasis role="italic">/conf/server.xml</emphasis> you can add an <emphasis role="italic">address</emphasis> attribute with the value <emphasis role="italic">localhost</emphasis> to the Connetor element for HTTP 1.1 like this:</para>
      <para><screen>&lt;Connector address=&quot;localhost&quot; protocol=&quot;HTTP/1.1&quot; ... &gt;</screen></para>
      <important>
        <para>The location block for static content is essential as web browsers will not cache static content by default over SSL. It will only cache such content on the client side if told explicitly by the web server.</para>
      </important>
    </section>
    <section>
      <title>Habilitando SSL en nginx</title>
      <para>In order to improve security it is recommended to configure the server running DHIS to communicate with clients over an encrypted connection and to identify itself to clients using a trusted certificate. This can be achieved through SSL which is an cryptographic communication protocol running on top of TCP/IP.</para>
      <para>To configure nginx to use SSL you will need a proper SSL certificate from an SSL provider. The cost of a certificate varies a lot depending on encryption strength. An affordable certificate from <ulink url="http://www.rapidsslonline.com">Rapid SSL Online</ulink> should serve most purposes. To generate the CSR (certificate signing request) you can invoke the  command below. When you are prompted for the <emphasis role="italic">Common Name</emphasis>, enter the fully qualified domain name for the site you are securing.</para>
      <screen>openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr</screen>
      <para>When you have your certificate files (.pem and .key) you will need to place them in a location which is reachable by nginx. A good location for this can be the same directory as where your nginx.conf file is located.</para>
      <para>Below is an nginx server block where the certificate files are named server.crt and server.key. Since SSL connections usually occur on port 443 (HTTPS) we pass requests on that port (443) on to the DHIS instance running on <emphasis role="italic">http://localhost:8080</emphasis> The first server block will rewrite all requests connecting to port 80 and force the use of HTTPS/SSL. This is also necessary because DHIS is using a lot of redirects internally which must be passed on to use HTTPS. Remember to replace <emphasis role="italic">&lt;server-ip&gt;</emphasis> with the  IP of your server. These blocks should replace the  one from the previous section.</para>
      <screen><![CDATA[# Rewrite block to force use of SSL

server {
  listen     80;
  rewrite    ^ https://<server-ip>$request_uri? permanent;
}

# SSL server block

server {
  listen               443;
  client_max_body_size 10M;

  ssl                  on;
  ssl_certificate      server.crt;
  ssl_certificate_key  server.key;

  ssl_session_timeout  5m;

  ssl_protocols              SSLv2 SSLv3 TLSv1;
  ssl_ciphers                HIGH:!aNULL:!MD5;
  ssl_prefer_server_ciphers  on;

  # Root points to your DHIS webapp location, update it!

  location ~ (\.js$|\.css$|\.gif$|\.woff$|\.ttf$|\.eot$|^/images/|^/icons/|^/dhis-web-commons/.*\.png$) {
    root     /home/dhis/tomcat/webapps/ROOT;
    expires  4d;
  } 

  location / {
    proxy_pass        http://localhost:8080/;
    proxy_redirect    off;
    proxy_set_header  Host            $host;
    proxy_set_header  X-Real-IP       $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
 }
}]]></screen>
    </section>
    <section>
      <title>Scripts de control para nginx</title>
      <para>In certain situations a server might reboot unexpectedly. It is hence preferable to have Tomcat and nginx start automatically when the server starts. To achieve that the first step is to create init scripts. Create a new file called <code>tomcat</code> and paste the below content into it (adjust the HOME variable to your environment):</para>
      <screen>#!/bin/sh
#Tomcat init script

HOME=/home/dhis/tomcat/bin

case $1 in
start)
        sh ${HOME}/startup.sh
        ;;
stop)
        sh ${HOME}/shutdown.sh
        ;;
restart)
        sh ${HOME}/shutdown.sh
        sleep 5
        sh ${HOME}/startup.sh
        ;;
esac
exit 0</screen>
      <para>Create a new file called <code>nginx</code> and paste the below content into it:</para>
      <screen>#!/bin/sh
#nginx init script

DAEMON=/usr/local/nginx/sbin/nginx

case $1 in
start)
        start-stop-daemon --start --exec $DAEMON
        ;;
stop)
        start-stop-daemon --stop --exec $DAEMON
        ;;
restart)
        start-stop-daemon --stop --exec $DAEMON
        sleep 1
        start-stop-daemon --start --exec $DAEMON
        ;;
esac
exit 0</screen>
      <para>Move both scripts to the init script directory and make them executable by invoking:</para>
      <screen>sudo mv tomcat nginx /etc/init.d
sudo chmod +x /etc/init.d/nginx /etc/init.d/tomcat</screen>
      <para>Next make sure the init scripts will be invoked during system startup  and shutdown:</para>
      <screen>sudo /usr/sbin/update-rc.d -f nginx defaults 80
sudo /usr/sbin/update-rc.d -f tomcat defaults 81</screen>
      <para>Tomcat and nginx will now be started at system startup and stopped at system shutdown. If you later need to revert this you can replace <code>defaults</code> with  <code>remove</code> and invoke the above commands again.</para>
    </section>
    <section>
      <title>Poner recursos disponibles con nginx</title>
      <para><emphasis role="bold">Making resources publicly available</emphasis></para>
      <para>In some scenarios it is desirable to make certain resources publicly available on the Web without requiring authentication. One example is when you want to make data analysis related resources in the Web API available in a Web portal. The following example will allow access to charts, maps, reports, report table and document resources through basic authentication by injecting an <emphasis role="italic">Authorization</emphasis> HTTP  header into the request. It will remove the Cookie header from the request and the Set-Cookie header from the response in order to avoid changing the currently logged in user. It is recommended to create a user for this purpose given only the minimum authorities required. The Authorization value can be constructed by Base64-encoding the username appended with a colon and the password and prefix it &quot;Basic &quot;, more precisely &quot;Basic base64_encode(username:password)&quot;. It will check the HTTP method used for requests and return <emphasis role="italic">405 Method Not Allowed</emphasis> if anything but GET is detected.</para>
      <screen>location ~ ^/api/(charts|maps|reports|reportTables|documents)/ {
  if ($request_method != GET) {
    return 405;
  }

  proxy_pass        http://localhost:8080;
  proxy_redirect    off;
  proxy_set_header  Host              $host;
  proxy_set_header  X-Real-IP         $remote_addr;
  proxy_set_header  X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header  Authorization     &quot;Basic YWRtaW46ZGlzdHJpY3Q=&quot;;
  proxy_set_header  Cookie            &quot;&quot;;
  proxy_hide_header Set-Cookie;
}</screen>
    </section>
    <section>
      <title>Configuración básica reversa de proxy con Apache</title>
      <para>The Apache HTTP server is the most common </para>
      <important>
        <para>Using nginx is the preferred option as reverse proxy with DHIS2 and you should not attempt to install both nginx and Apache on the same server. If you have installed nginx please ignore this section. </para>
      </important>
      <para>The Apache HTTP server is the most widely used HTTP server currently. Depdenign on your exact nature of deployment, you may need to use Apache as a reverse proxy for your DHIS2 server. In this section, we will describe how to implement a simple reverse proxy setup with Apache. </para>
      <para>First we need to install a few necessary programs modules for Apache and enable the modules. </para>
      <para><screen>sudo apt-get install apache2 libapache2-mod-proxy-html libapache2-mod-jk
a2enmod proxy proxy_ajp proxy_connect</screen></para>
      <para>Lets define an AJP connector which Apache HTTP server will use to connect to Tomcat with. The Tomcat <filename>server.xml</filename> file should be located in the /conf/ director of your Tomcat installation. Be sure this line is uncommented.You can set the port to anything you like which is unused.</para>
      <para><screen>&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
</screen>Now, we need to make the adjustments to the Apache HTTP server which will answer requests on port 80 and pass them to the Tomcat server through an AJP connector. Edit the file <filename>/etc/apache2/mods-enabled/proxy.conf</filename> so that it looks like the example below.  Be sure that the port defined in the configuration file matches the one from Tomcat.</para>
      <para><screen>&lt;IfModule mod_proxy.c&gt;

ProxyRequests Off
ProxyPass /dhis  ajp://localhost:8009/dhis
ProxyPassReverse /dhis  ajp://localhost:8009/dhis

&lt;Location &quot;/dhis&quot;&gt;
  Order allow,deny
  Allow from all
&lt;/Location&gt;     
&lt;/IfModule&gt;
</screen></para>
      <para>You now can restart Tomcat and the Apache HTTPD server and your DHIS 2 instance should be available on http://<emphasis>myserver</emphasis>/dhis where <emphasis>myserver</emphasis> is the hostname of your server. </para>
    </section>
    <section>
      <title>Balanceo de carga básico con Apache y Tomcat</title>
      <para>Load balancing may be employed to more evenly distribute system load across multiple Tomcat instances in situations where user load is too high to be handled by a single server instance. In this example, we will create a simple load-balanced architecture using &quot;sticky sessions&quot; to distribute users across two instances of Tomcat. </para>
      <para>First, we need at least two instances of Tomcat running DHIS2, which are connected to the same database. There are various architectures, such as running the application servers (Tomcat) on separate (virtual) machines connected to a single database server, or perhaps running multiple Tomcat instances and a database on a single-high capacity machine in situations with I/O is not an issue, but when CPU usage of a single Tomcat instance limits overall system performance. In this scenario, we will configure connect two Tomcat instances running on the same machine to a single database through a load-balanced reverse proxy. Apache will take care of the details of determining which Tomcat instance a particular client is interfaced to with the </para>
      <para>The first step is to configure our  Tomcat instances. The previous sections have detailed how this should be done. Importantly, both Tomcat instances should be configured to use the same database server. Some modifications need to be made to the server.xml file of each Tomcat instance, which will be used to uniquely identify each instance. Two copies of Tomcat should be extracted to a directory of your choice. Modify the server.xml file so that the following lines are unique for each instance. </para>
      <para><screen>&lt;Server port=&quot;<emphasis>800<emphasis>5</emphasis></emphasis>&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
...
&lt;Connector port=<emphasis>&quot;8009</emphasis>&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8444&quot; /&gt;
...

&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;<emphasis>jvm1</emphasis>&quot;&gt;</screen></para>
      <para>The important parameters here are the server port, the AJP connector port, and the <parameter>jvmRoute</parameter> identifier. The <parameter>jvmRoute</parameter> identifier will be appended to the JSESSIONID so that Apache will know which Tomcat instance a particular session should be routed to. The parameters must be unique for each Tomcat instance. After configuring Tomcat, setup DHIS2 according to the normal procedures detailed in other sections.  </para>
      <para>Next, we will configure the Apache HTTP server to perform load balancing. Incoming client requests will be assigned to one of the instances with a sticky session. Alter the <filename>/etc/apache2/apache2.conf </filename>file (or other appropriate file depending on your exact configuration) to define a proxy load balancer and a proxy and reverse proxy path. Note that the port numbers and <parameter>route</parameter> parameters must match the Tomcat port and <parameter>jvmRoute</parameter> parameters which were defined earlier in the Tomcat configuration.</para>
      <screen>&lt;Proxy balancer://dhiscluster&gt;
Order Allow,Deny
Allow from all
&lt;/Proxy&gt;

&lt;Proxy balancer://dhiscluster&gt;
BalancerMember ajp://127.0.0.1:8009/dhis route=dhis1
BalancerMember ajp://127.0.0.1:9009/dhis route=dhis2

ProxySet lbmethod=byrequests
ProxySet stickysession=JSESSIONID
&lt;/Proxy&gt;

ProxyVia Off
ProxyPass /dhis/ balancer://dhiscluster/ stickysession=JSESSIONID nofailover=on

ProxyPassReverse /dhis/ balancer://dhiscluster/ stickysession=JSESSIONID|jsessionid
</screen>
      <para>Finally, start both Tomcat instances, and then restart Apache HTTP. </para>
      <para>This example demonstrates how to implement a simple load balanced system with sticky sessions using Apache HTTP server.</para>
    </section>
    <section>
      <title>Encriptado básico SSL con Apache</title>
      <para>Using Apache and the reverse proxy  setup described in the previous section, we can easily implement encrypted transfer of data between clients and the server over HTTPS. This section will describe how to use self-signed certificates, although  the same procedure could be used if you have fully-signed certificates as well. </para>
      <para>First (as root), generate the necessary private key files and CSR (Certificate Signing Request) </para>
      <screen>mkdir /etc/apache2/ssl
cd /etc/apache2/ssl
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr</screen>
      <para>We need to remove the password from the key, otherwise Apache will not be able to use it. </para>
      <para><screen>cp server.key server.key.org
openssl rsa -in server.key.org -out server.key</screen></para>
      <para>Next, generate a self-signed certificate which will be valid for one year.</para>
      <screen>openssl x509 -req -days 365 -in server.csr -signkey \ server.key -out server.crt</screen>
      <para>Now, lets configure Apache by enabling the SSL modules and creating a default site.</para>
      <screen>a2enmod ssl
a2ensite default-ssl</screen>
      <para>Now, we need to edit the default-ssl (located at <filename>/etc/apache2/sites-enabled/default-ssl</filename>) file in order to enable the SSL transfer functionality of Apache. </para>
      <para><screen>&lt;VirtualHost *:443&gt;
        ServerAdmin wemaster@mydomain.org
       SSLEngine On
       SSLCertificateFile /etc/apache2/ssl/server.crt
       SSLCertificateKeyFile /etc/apache2/ssl/server.key
...</screen></para>
      <para>Be sure that the *:80 section of this file is changed to port *:443, which is the default SSL port. Also, be sure to change the ServerAdmin to the webmaster&apos;s email. Lastly, we need to be sure that the hostname is setup properly in /etc/hosts. Just under the &quot;localhost&quot; line, be sure to add the server&apos;s IP address and domain name. </para>
      <para><screen>127.0.0.1 localhost
XXX.XX.XXX.XXX foo.mydomain.org</screen></para>
      <para>Now, just restart Apache and you should be able to view https://foo.mydomain.org/dhis. </para>
      <screen>/etc/init.d/apache2 restart</screen>
    </section>
  </section>
  <section>
    <title>Configuración de DHIS 2 Live</title>
    <para>The DHIS 2 Live package is extremely convenient to install and run. It is intended for demonstrations, for users who want to explore the system and for small, offline installations typically at districts or facilities. It only requires a Java Runtime Environment and runs on all browsers except Internet Explorer 7 and lower.</para>
    <para>To install start by downloading DHIS 2 Live from <emphasis role="italic">http://dhis2.org</emphasis> and extract the archive to any location. On Windows click the executable archive. On Linux invoke the startup.sh script. After the startup process is done your default web browser will automtically be pointed to  <emphasis role="italic">http://localhost:8082</emphasis> where the application is accessible. A system tray menu is accessible on most operating systems where you can start and stop the server and start new browser sesssions. Please note that if you have the server running there is no need to start it again, simply open the application from the tray  menu.</para>
    <para>DHIS 2 Live is running on an embedded Jetty servlet container and an embedded H2 database. However it can easily be configured to run on other database systems such as PostgreSQL. Please read the section above about server installations for an explanation of the database configuration. The <emphasis role="italic">hibernate.properties</emphasis> configuration file is located in the <emphasis role="italic">conf</emphasis> folder. Remember to restart the Live package for your changes to take effect. The server port is 8082 by default. This can be changed by modifying the value in the<emphasis role="italic"> jetty.port</emphasis> configuration file located in the <emphasis role="italic">conf</emphasis> directory.</para>
  </section>
  <section>
    <title>Backup</title>
    <para>Doing automated database backups for information systems in production is an absolute must, and might have uncomfortable consequences if ignored. Backups have two main purposes: The primary is data recovery in case data is lost, the secondary purpose is archiving of data for a historical period of time.</para>
    <para>Backup should be central in a disaster recovery plan. Even though such a plan should cover additional subjects, the database is the key component to consider since this is where all data used in the DHIS 2 application is stored. Most other parts of the IT infrastructure surrounding the application can be restored based on standard components.</para>
    <para>There are of course many ways to set up backup; however the following describes a setup where the database is copied into a dump file and saved on the file system. This can be considered a <emphasis role="italic">full</emphasis> backup. The backup is done with a <emphasis role="italic">cron job</emphasis>, which is a time-based scheduler in Unix/Linux operating systems.</para>
    <remark>You can download both files from http://dhis2.com/download/pg_backup.zip</remark>
    <para>The cron job is set up with two files. The first is a <emphasis role="italic">script</emphasis> which performs the actual task of backup up the database. It uses a PostgreSQL program called <emphasis role="italic">pg_dump</emphasis> for creating the database copy. The second is a crontab file which runs the backup script every day at 23:00. Note that this script backs up the database file to the local disk. It is strongly recommended to store a copy of the backup at a location outside the server where the application is hosted. This can be achieved with the <emphasis role="italic">scp</emphasis> tool. Make sure that you have set the system date correctly on your server.</para>
  </section>
  <section>
    <title>Usando los servicios Web Amazon</title>
    <para>Amazon Web Services (AWS) offers virtual cloud-computing resources which allow developers and implementers to quickly scale an application, both horizontally and vertically, in a cost effective manner. AWS offers multiple operating systems and instance sizes depending on the exact nature of the deployment. This section will describe a basic setup with the AWS Elastic Cloud Compute (EC2) system using the Basic 32 bit Amazon AMI, which is based on the Red Hat Linux distribution. </para>
    <para>Estimating the cost of an AWS instance can be performed using the<ulink url="http://calculator.s3.amazonaws.com/calc5.html"> &quot;Simple Monthly Cal culator&quot;</ulink>. AWS costs are based entirely on usage. As your application usage grows, you can provision new servers. </para>
    <orderedlist>
      <listitem>
        <para>You will need an existing AWS account. If you do not have one, you can create one <ulink url="http://aws.amazon.com/">here</ulink>.  Once you have created and enabled your account, login to the<ulink url="https://console.aws.amazon.com/s3/home"> AWS console</ulink>. </para>
      </listitem>
      <listitem>
        <para>Once you have logged in, select the &quot;EC2&quot; tab. You will need to select a region in which to instantiate your instance. Users in Europe and Africa, should probably use the EU West region, while users in Asia should probably use on of the Asia Pacific regions (either Singapore or Tokyo). Selection of the appropriate region will reduce latency between the server and clients.</para>
      </listitem>
      <listitem>
        <para>Click the &quot;Instances&quot; link on the right menu, and then the &quot;Launch Instances&quot; button. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/create_instance.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
        <para>Select one of the AMIs for your server. Using either of the Basic Amazon AMIs (either 32 or 64 bit) is recommended, but you can use whichever AMI is most appropriate. </para>
      </listitem>
      <listitem>
        <para>Next, you will need to select the size of your instance. The size of the instance selected will depend on the number of anticipated users. Selecting the &quot;Micro&quot; size, will enable you to test DHIS  2 in the AWS environment for a period of one year, at no cost if you use one of the &quot;Free tier eligible&quot; AMIs. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/instance_size.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>Once you have selected the instance size, you can select a specific kernel ID and RAM disk ID. If you do not have a specific reason, just use the defaults and proceed to the next dialog. </para>
      </listitem>
      <listitem>
        <para>Next, you can add key-value pairs to help you to easily identify the instance. This is just metadata for your own usage. </para>
      </listitem>
      <listitem>
        <para>Next, you will need a key pair which will enable you to remotely access your instance. If you have an existing key pair you can use it, otherwise, you can create a new key pair. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="60%" align="center" fileref="resources/images/aws/create_key_pairs.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>You will need to assign a security group to the instance. Security groups can be used to expose certain services (SSH, HTTP, Tomcat, etc) to the Internet.With security groups, you can control which ports will be open to specific network ranges. For DHIS 2, you would normally need at least port 22 (SSH) and port 80 (HTTP) open to the internet or specific address ranges. </para>
        <screenshot>
          <mediaobject>
            <imageobject>
              <imagedata width="50%" align="center" fileref="resources/images/aws/security_groups.png"/>
            </imageobject>
          </mediaobject>
        </screenshot>
      </listitem>
      <listitem>
        <para>Finally, you can review and launch your instance. </para>
      </listitem>
      <listitem>
        <para>Once the instance, has been launched, you can connect via PuTTY or any other SSH client to the instance using the instance&apos;s Public DNS, which is listed on the EC2 control panel. You will need to install a few packages if you are using the Amazon default AMI.</para>
        <screen>yum install jdk.i586 postgresql-server.i686 apache-tomcat-apis.
noarch tomcat-native.i686 httpd.i686</screen>
      </listitem>
      <listitem>
        <para>Once you have installed these packages, you can follow the instructions provided in the  on setting up a server.  </para>
      </listitem>
    </orderedlist>
  </section>
</chapter>
